''' Algorithm --- It is a step by step procedure to approach or solve a problem
--- Algorithm is written in simple english we don't use any coding
---- Algorithms can be expressed using diagrams also





1. Charactristics of an algorithm
1.Unambigous --- Algorithms should be crystal clear and all steps should lead to a single solutionss

2.Input--- input in an algorithm should be well defined. And there can be multiple inputs

3.Output -- It is mandotary to have at least one output and it should match the desired result

4.finitness --- An algorithm should terminate after its implementation

5.Feasibility --- The given algorithm should be feasible with the available resources.

6.Independent --- The algorithm should be independent of any programing language







****** Algorithm analysis
1. priory analysis --- This is theoratical analysis where we assume all the values to be ideal..
we do this before the implementation of the algorithm.

2. posterior analysis ---- result base analysis where we already have implemented the algorithm and we have the...
statiscial data with us regarding the algorithm.







*** Algorithm complexity
1. Space complexity --- The amount of resource / space required to fulfill the algorithm

2.Time complexity --- The tells us about the time required for the execution of the algorithm




**** Asymptotic notation --- when you want to describe a given algorithm along the boundry ...
conditions which specifically focuses time complexity
1. Best - Omega notation --- This defines the lower bound or the least amount of time riquired

2. Average --- Theta notation --- This defines the actually occured time

3. Big o notation(oh) --- worst --- This defines the upper bound or the maximum amount of time for an..
algorithm to execute.





*** Algorithm optimisation techniques
1. Greedy approach --- we design algorithm to get output in the best time and less space

2. Divide and conquer approach ---
a) divide / break -- you to divide your problem into smaller sub problems .
b) conquer / solve -- solve individual problems one by one
c) join / merge --- combine all solutions and automatically you will get the final solution


3. Dynamic approach --- This is very similar to divide and conquer , that you keep track of solutions
and reuse the solutions .



































when you want to go through a BT or BST it is called as Tree travarsal

1. inorder travarsal
--- then root/ of the node
--- right child node



2 preorder traversal  ---- you will first go to the root
--- u will go to the left child node
---- u will the right child node

3. postorder traversal  --- you will first go to the left child node
--- you will go to the right child node
-- You will go to the root







'''